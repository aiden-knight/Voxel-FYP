#version 450

struct Vertex {
	vec3 position;
	vec3 normal;
};

struct Particle {
	vec4 position;
	vec4 velocity;
	vec4 colour;
};

layout (binding = 0) uniform ParameterUBO {
	int voxelResolution;
	float halfExtent;
	uint indexCount;
} ubo;

layout(std140, binding = 1) readonly buffer VerticesIn {
	Vertex vertices[ ];
};

layout(std140, binding = 2) readonly buffer IndicesIn {
	uint indices[ ];
};

layout(std140, binding = 3) buffer ParticleSSBOOut {
	Particle particlesOut[ ];
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

float voxelHalfExtent = ubo.halfExtent / ubo.voxelResolution;
float increment = voxelHalfExtent * 2;

#define pi 3.1415926535897932384626433832795
float halfPi = pi/2;

float ATAN2(float y, float x)
{
	if (x > 0.0)
		return atan(y / x);
	else if (x < 0.0)
	{
		if (y < 0.0)
			return atan(y / x) - pi;
		else // y is greater than or equal to 0
			return atan(y / x) + pi;
	}
	else // x equal to 0
	{
		if (y < 0.0)
			return -halfPi;
		else if (y > 0.0)
			return halfPi;
		else // y equal to 0
			return 0.0;
	}
}

void main() {
	vec3 position = vec3(
		gl_GlobalInvocationID.x * increment - ubo.halfExtent,
		gl_GlobalInvocationID.y * increment - ubo.halfExtent,
		gl_GlobalInvocationID.z * increment - ubo.halfExtent		
	);

	uint index = gl_GlobalInvocationID.x * ubo.voxelResolution * ubo.voxelResolution +
		gl_GlobalInvocationID.y * ubo.voxelResolution +
		gl_GlobalInvocationID.z;
	
	float occupancy = 0;

	for(uint i = 0; i < ubo.indexCount; i += 3)
	{
		mat3 edges;
		for(uint j = 0; j < 3; ++j)
		{
			vec3 vertexPos = vertices[indices[i + j]].position;
			edges[j] = normalize(vertexPos);
		}

		float alpha = determinant(edges);
		float beta = 1 + dot(edges[0], edges[1]) + dot(edges[1], edges[2]) + dot(edges[2], edges[0]);
		occupancy += ATAN2(alpha, beta);
	}

	if(occupancy >= 1.0)
	{
		Particle particle;
		particle.position = vec4(position, 0.0);
		particle.velocity = particle.position;

		particle.colour = normalize(particle.position);
		particle.colour += 1;
		particle.colour /= 2;
		if (dot(particle.colour, particle.colour) < 0.1)
			particle.colour = vec4(0.3);
		
		particle.colour.w = 1.0;

		particlesOut[index] = particle;
	}
	else
	{
		particlesOut[index].colour = vec4(0.0);
	}
}